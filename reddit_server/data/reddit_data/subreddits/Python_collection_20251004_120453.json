{
  "subreddit": "Python",
  "posts": [
    {
      "id": "1nstje8",
      "title": "Stop uploading your code to sketchy ‚Äúonline obfuscators‚Äù like freecodingtools.org",
      "selftext": "So I googled one of those ‚Äúfree online Python obfuscor things‚Äù (say, freecodingtools.org) and oh boy‚Ä¶ I have to rant for a minute.\n\nYou sell pitch is just ‚Äújust paste your code in this box and we‚Äôll keep it for you.‚Äù Right. Because clearly the best way to keep your intellectual property is to deposit it on a who-knows-what site you‚Äôve never ever known, owned and operated people you‚Äôll never ever meet, with no idea anywhere your source goes. Completely secure.\n\nEven if you think the site will not retain a copy of your code, the real ‚Äúobfuscation‚Äù is going to be farcical. We discuss base64, XOR, hex encoding, perhaps zlib compression, in a few spaghetti exec function calls. This isn‚Äôt security, painting and crafts. It can be unwritten anybody who possesses a ten-minute-half-decent Google. But geez, at least it does look menacing from a first glance, doesn‚Äôt it?\n\nYou actually experience a false sense of security and the true probability of having just opened your complete codebase to a dodgy server somewhere. And if you‚Äôre particularly unlucky, they‚Äôll mail back to you a ‚Äúprotected‚Äù file that not only includes a delicious little backdoor but also one you‚Äôll eagerly send off to your unsuspecting users. Well done, you just gave away supply-chain malware for free.\n\nIf you truly do want to protect code, there are actual tools for it. Cython runs to C extensions. Nuitka runs projects to native executables. Encrypts bytecode and does machine binding. Not tricks, but at least make it hard and come from people who don‚Äôt want your source comed to be pushed to their private webserver. And the actual solution? Don‚Äôt push secrets to begin with. Put keys and sensitive logic on a server people can‚Äôt touch.\n\nSo yeh‚Ä¶ do not the next time your eyes glaze over at ‚Äújust plug your Python code into our free web obfuscator.‚Äù Unless your security mindset is ‚Äúkeep my younger brother from cheating and reading my homework,‚Äù congratulations, your secret‚Äôs safe.",
      "author": "GuiltyAd2976",
      "subreddit": "Python",
      "created_utc": "2025-09-28T18:03:25",
      "score": 389,
      "upvote_ratio": 0.88,
      "num_comments": 55,
      "permalink": "/r/Python/comments/1nstje8/stop_uploading_your_code_to_sketchy_online/",
      "url": "https://www.reddit.com/r/Python/comments/1nstje8/stop_uploading_your_code_to_sketchy_online/",
      "is_self": true,
      "is_video": false,
      "over_18": false,
      "link_flair_text": "Discussion",
      "retrieved_at": "2025-10-04T12:04:52.921886"
    },
    {
      "id": "1nx0oxk",
      "title": "PEP 810 ‚Äì Explicit lazy imports",
      "selftext": "PEP: https://pep-previews--4622.org.readthedocs.build/pep-0810/\n\nDiscussion: https://discuss.python.org/t/pep-810-explicit-lazy-imports/104131\n\nThis PEP introduces lazy imports as an explicit language feature. Currently, a module is eagerly loaded at the point of the import statement. Lazy imports defer the loading and execution of a module until the first time the imported name is used.\n\nBy allowing developers to mark individual imports as lazy with explicit syntax, Python programs can reduce startup time, memory usage, and unnecessary work. This is particularly beneficial for command-line tools, test suites, and applications with large dependency graphs.\n\nThe proposal preserves full backwards compatibility: normal import statements remain unchanged, and lazy imports are enabled only where explicitly requested.",
      "author": "JanEric1",
      "subreddit": "Python",
      "created_utc": "2025-10-03T15:28:35",
      "score": 372,
      "upvote_ratio": 0.97,
      "num_comments": 123,
      "permalink": "/r/Python/comments/1nx0oxk/pep_810_explicit_lazy_imports/",
      "url": "https://www.reddit.com/r/Python/comments/1nx0oxk/pep_810_explicit_lazy_imports/",
      "is_self": true,
      "is_video": false,
      "over_18": false,
      "link_flair_text": "News",
      "retrieved_at": "2025-10-04T12:04:52.921895"
    },
    {
      "id": "1ntmao7",
      "title": "Why would I not use Visual Studio code",
      "selftext": "I‚Äôm doing a college project that wants me to use Mobaxterm for my terminal and WinSCP to transfer files and I‚Äôm using a college provided Linux server. In mobaxterm I use a code editor called nedit. \n\nI‚Äôve used VSC on a project before and it was so much easier , and everything was built in one. I told the professor and he said well you could but I think this is better. \n\nI‚Äôm confused how this slow multi step process can be better than VSC?\n\n(This is a bioinformatics project using biopython)",
      "author": "saddickstic",
      "subreddit": "Python",
      "created_utc": "2025-09-29T17:14:14",
      "score": 273,
      "upvote_ratio": 0.86,
      "num_comments": 173,
      "permalink": "/r/Python/comments/1ntmao7/why_would_i_not_use_visual_studio_code/",
      "url": "https://www.reddit.com/r/Python/comments/1ntmao7/why_would_i_not_use_visual_studio_code/",
      "is_self": true,
      "is_video": false,
      "over_18": false,
      "link_flair_text": "Discussion",
      "retrieved_at": "2025-10-04T12:04:52.921900"
    },
    {
      "id": "1nv3tgp",
      "title": "Logly üöÄ ‚Äî a Rust-powered, super fast, and simple logging library for Python",
      "selftext": "**What My Project Does**\n\ni am building an Logly a  **logging library for Python** that combines simplicity with **high performance** using a Rust backend. It supports:\n\n* Console and file logging\n* JSON / structured logging\n* Async background writing to reduce latency\n* Pretty formatting with minimal boilerplate\n\nIt‚Äôs designed to be **lightweight, fast, and easy to use**, giving Python developers a modern logging solution without the complexity of the built-in `logging` module.\n\n**Latency Microbenchmark (30,000 messages):**\n\n|Percentile|`logging`Python|Logly|Speedup|\n|:-|:-|:-|:-|\n|p50|0.014 ms|0.002 ms|7√ó|\n|p95|0.029 ms|0.002 ms|14.5√ó|\n|p99|0.043 ms|0.015 ms|2.9√ó|\n\n>\n\n\\> **Note:** Performance may vary depending on your OS, CPU, Python version, and system load. Benchmarks show **up to 10√ó faster performance** under high-volume or multi-threaded workloads, but actual results will differ based on your environment.\n\n**Target Audience**\n\n* Python developers needing high-performance logging\n* Scripts, web apps, or production systems\n* Developers who want structured logging or async log handling without overhead\n\n**Logging Library Comparison**\n\n|Feature / Library|`logging`Python|Loguru|Structlog|**Logly (v0.1.1)**|\n|:-|:-|:-|:-|:-|\n|**Backend**|Python|Python|Python|Rust|\n|**Async Logging**|‚ùå|‚úÖ (basic)|‚úÖ|‚úÖ (high-performance, async background writer)|\n|**File & Console Logging**|‚úÖ|‚úÖ|‚úÖ|‚úÖ|\n|**JSON / Structured Logging**|‚úÖ (manual)|‚úÖ|‚úÖ|‚úÖ (built-in, easy)|\n|**Ease of Use**|Medium|High|Medium|High (simple API, minimal boilerplate)|\n|**Performance (single-threaded)**|Baseline|\\~1.5‚Äì2√ó faster|\\~1√ó|\\~3.5√ó faster|\n|**Performance (multi-threaded / concurrent)**|Baseline|\\~2‚Äì3√ó|\\~1√ó|**up to 10√ó faster** üöÄ|\n|**Pretty Formatting / Color**|‚ùå / limited|‚úÖ|‚ùå|‚úÖ|\n|**Rotation / Retention**|‚úÖ (config-heavy)|‚úÖ|Limited|‚úÖ|\n|**Additional Notes**|Standard library, reliable, but verbose and slower|Easy setup, friendly API|Structured logging focus|Rust backend, optimized for high-volume, async, low-latency logging|\n\n**Example Usage**\n\n    from logly import logger\n    \n    logger.info(\"Hello from Logly!\")\n    logger.debug(\"Logging asynchronously to a file\")\n    logger.error(\"Structured logging works too!\", extra={\"user\": \"alice\"})\n\n**Links**\n\n* GitHub (open source): [https://github.com/muhammad-fiaz/logly/](https://github.com/muhammad-fiaz/logly/)\n* PyPI: [https://pypi.org/project/logly/](https://pypi.org/project/logly/)\n\n**To Get Started:**\n\n    pip install logly\n\nPlease feel free to **check it out, give feedback, and report any issues** on GitHub or PyPI. I‚Äôd really appreciate your thoughts and contributions! üôÇ\n\n**Note: This Project is Not Vibe-Coded or AI Used i am Only Have Used AI for Documentation Purposes to Speed up Initial Development Only, the Code itself is Mine and Implemented by Mine (No AI Usage from the start itself) and also the performance of logly is not tested fully yet because this project is still in active development!**\n\n**UPDATE!!! üöÄ** (03-10-2025) Thanks for all the feedback, everyone! Based on user requests, I‚Äôve improved **Logly v0.1.4** (Released now) and added some new features. I‚Äôve also updated the documentation for better clarity.\n\n‚úÖ Currently, Logly supports **Linux, Windows, and macOS** for **Python 3.10 to 3.13**. üìñ Please report any issues or errors directly on **GitHub,** that‚Äôs the best place for bug reports and feature requests (not Reddit). For broader conversations, please use [**GitHub Discussions**](https://github.com/muhammad-fiaz/logly/discussions).\n\nFor those [asking for proof of my work](https://www.reddit.com/r/Python/comments/1nv3tgp/comment/nhdisrd/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button): I‚Äôve been actively coding and tracking my projects via [WakaTime](https://wakatime.com/@muhammadfiaz), and I have a good community supporting my work.\n\nI understand some people may not like the project, and that‚Äôs fine, you‚Äôre free to have your opinion. But if you want to give constructive feedback, please do it openly on GitHub under your real account instead of throwaway or anonymous ones. That way, the feedback is more helpful and transparent.\n\nBTW! I take **docstrings and documentation very seriously :) ,** I personally review every single one each time to ensure quality and clarity. If anything is missing or not updated for the latest release, you can always create an issue or a PR. I always welcome contributions.\n\nAlso, judging whether I used AI just based on [my *constant*¬†bullet points, bold text or docstrings ](https://www.reddit.com/r/Python/comments/1nv3tgp/comment/nh9h8ua/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)in the Rust code? That‚Äôs really childish,  comments and docstrings alone aren‚Äôt proof of anything. I always make sure to add both to keep everything well-documented for contributors, and also saying \"[Rust Devs don't use comments and docstrings](https://www.reddit.com/r/Python/comments/1nv3tgp/comment/nhe8f9v/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)\" but I‚Äôve seen plenty of experienced Rust developers use them as well, in Rust and across all programming languages.\n\nFinally üôÇ I am not promoting or making statements about whether using AI is right or wrong, good practice or bad practice, it depends entirely on your use case and personal preference and up to you only.\n\nIf you still insist this is ‚Äúvibe coding,‚Äù then fine, that‚Äôs your opinion. If not, then it‚Äôs whatever, I don‚Äôt care. I am using my **real name** and being transparent. Just because I work on this project personally doesn‚Äôt mean it‚Äôs for a [job or resume](https://www.reddit.com/r/Python/comments/1nv3tgp/comment/nh7zjyc/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button); I‚Äôve clearly stated that in my profile. If you want to collaborate, feel free to do so for **improvements**, but commenting about [useless things](https://www.reddit.com/r/Python/comments/1nv3tgp/comment/nhdyz6a/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button) or **misleading claims by** [puppeteer accounts](https://www.reddit.com/user/bay400/) doesn‚Äôt help anyone.\n\nI wrote this message for people who are genuinely interested in creating new methods or contributing. [I am not promoting the project simply because it‚Äôs in Rust](https://www.reddit.com/r/Python/comments/1nv3tgp/comment/nhdyp23/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button),I wanted **feedback**, which is why I‚Äôm asking for input here for improvement, not for childish debates about whether I used AI or not.\n\nAt the end of the day, we‚Äôre all here to learn, whether you have 20+ years of experience in IT or you‚Äôre just a newbie. **Constructive discussion and improvements help everyone grow.**\n\nAnd just to be clear I‚Äôm doing this to build awesome things in public and grow in public, so people can see the progress, learn, and contribute along the way :)\n\n**Thanks again for all your support! üôèüôÇ**",
      "author": "muhammad-fiaz",
      "subreddit": "Python",
      "created_utc": "2025-10-01T10:43:28",
      "score": 233,
      "upvote_ratio": 0.85,
      "num_comments": 132,
      "permalink": "/r/Python/comments/1nv3tgp/logly_a_rustpowered_super_fast_and_simple_logging/",
      "url": "https://www.reddit.com/r/Python/comments/1nv3tgp/logly_a_rustpowered_super_fast_and_simple_logging/",
      "is_self": true,
      "is_video": false,
      "over_18": false,
      "link_flair_text": "Showcase",
      "retrieved_at": "2025-10-04T12:04:52.921903"
    },
    {
      "id": "1nuaqe8",
      "title": "Stories from running a workflow engine, e.g., Hatchet, in Production",
      "selftext": "Hi everybody! I find myself in need of a workflow engine (I'm DevOps, so I'll be using it and administering it), and it seems the Python space is exploding with options right now. I'm passingly familiar with Celery+Canvas and DAG-based tools such as Airflow, but the hot new thing seems to be Durable Execution frameworks like Temporal.io, DBOS, Hatchet, etc. I'd love to hear stories from people actually using and managing such things in the wild, as part of evaluating which option is best for me.\n\nJust from reading over these projects docs, I can give my initial impressions:\n\n* Temporal.io - enterprise-ready, lots of operational bits and bobs to manage, seems to want to take over your entire project\n* DBOS - way less operational impact, but also no obvious way to horizontally scale workers independent of app servers (which is sort of a key feature for me)\n* Hatchet - evolving fast, Durable Execution/Workflow bits seem fairly recent, no obvious way to logically segment queues, etc. by tenant (Temporal has Namespaces, Celery+Canvas has Virtual Hosts in RabbitMQ, DBOS‚Ä¶ might be leveraging your app database, so it inherits whatever you are doing there?)\n\nAm I missing any of the big (Python) players? What has your experience been like?",
      "author": "gthank",
      "subreddit": "Python",
      "created_utc": "2025-09-30T12:34:07",
      "score": 101,
      "upvote_ratio": 0.98,
      "num_comments": 13,
      "permalink": "/r/Python/comments/1nuaqe8/stories_from_running_a_workflow_engine_eg_hatchet/",
      "url": "https://www.reddit.com/r/Python/comments/1nuaqe8/stories_from_running_a_workflow_engine_eg_hatchet/",
      "is_self": true,
      "is_video": false,
      "over_18": false,
      "link_flair_text": "Discussion",
      "retrieved_at": "2025-10-04T12:04:52.921906"
    }
  ],
  "count": 5
}